<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Brick - iPod Classic</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #2a2a2a;
            font-family: 'Chicago', 'Courier New', monospace;
            touch-action: pan-y;
            overflow: hidden;
        }
        
        .ipod-container {
            background: #d0d0d0;
            padding: 15px;
            border-radius: 25px;
            box-shadow: 
                inset -2px -2px 5px rgba(0,0,0,0.2),
                inset 2px 2px 5px rgba(255,255,255,0.7),
                0 10px 30px rgba(0,0,0,0.5);
            max-width: 95vw;
        }
        
        .screen {
            background: #9cb896;
            border: 3px solid #4a4a4a;
            border-radius: 5px;
            padding: 8px;
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .info-bar {
            background: #9cb896;
            color: #000;
            font-size: 11px;
            padding: 4px 8px;
            display: flex;
            justify-content: space-between;
            border-bottom: 1px solid #000;
            font-weight: bold;
            letter-spacing: 1px;
        }
        
        canvas {
            background: #9cb896;
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            touch-action: none;
        }
        
        .controls {
            margin-top: 15px;
            text-align: center;
        }
        
        .click-wheel-container {
            margin: 20px auto;
            position: relative;
            width: 180px;
            height: 180px;
        }
        
        .click-wheel {
            width: 180px;
            height: 180px;
            border-radius: 50%;
            background: radial-gradient(circle at 50% 40%, #f5f5f5, #c0c0c0);
            box-shadow: 
                inset 0 2px 5px rgba(255,255,255,0.7),
                inset 0 -2px 8px rgba(0,0,0,0.3),
                0 5px 15px rgba(0,0,0,0.3);
            position: relative;
            cursor: pointer;
            touch-action: none;
            user-select: none;
        }
        
        .click-wheel-center {
            position: absolute;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle at 50% 40%, #e8e8e8, #a0a0a0);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 
                0 2px 5px rgba(0,0,0,0.3),
                inset 0 1px 3px rgba(255,255,255,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
            color: #333;
            pointer-events: none;
        }
        
        .wheel-labels {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .wheel-label {
            position: absolute;
            font-size: 10px;
            font-weight: bold;
            color: #333;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .wheel-label.top {
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .wheel-label.bottom {
            bottom: 15px;
            left: 50%;
            transform: translateX(-50%);
        }
        
        .wheel-label.left {
            left: 20px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .wheel-label.right {
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
        }
        
        button {
            background: #e0e0e0;
            color: #000;
            border: 2px solid #4a4a4a;
            padding: 12px 24px;
            font-size: 14px;
            border-radius: 20px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 
                2px 2px 5px rgba(0,0,0,0.3),
                inset 1px 1px 2px rgba(255,255,255,0.7);
            font-family: 'Chicago', 'Courier New', monospace;
            touch-action: manipulation;
        }
        
        button:active {
            box-shadow: 
                inset 2px 2px 5px rgba(0,0,0,0.3),
                1px 1px 2px rgba(255,255,255,0.7);
        }
        
        .message {
            color: #000;
            font-size: 12px;
            margin: 8px 0;
            font-weight: bold;
            min-height: 20px;
            letter-spacing: 1px;
        }

        @media (max-width: 480px) {
            .ipod-container {
                padding: 10px;
            }
            
            button {
                padding: 15px 30px;
                font-size: 16px;
            }
        }
    </style>
</head>
<body>
    <div class="ipod-container">
        <div class="screen">
            <div class="info-bar">
                <span>♥<span id="lives">3</span></span>
                <span>BRICK</span>
                <span><span id="score">0</span></span>
            </div>
            <canvas id="gameCanvas" width="320" height="240"></canvas>
        </div>
        <div class="click-wheel-container">
            <div class="click-wheel" id="clickWheel">
                <div class="wheel-labels">
                    <div class="wheel-label top">MENU</div>
                    <div class="wheel-label right">▶▶</div>
                    <div class="wheel-label bottom">PLAY</div>
                    <div class="wheel-label left">◀◀</div>
                </div>
                <div class="click-wheel-center" id="centerButton">
                    SELECT
                </div>
            </div>
        </div>
        <div class="controls">
            <div class="message" id="message">TAP TO START</div>
            <button id="startBtn">▶ START</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const livesEl = document.getElementById('lives');
        const messageEl = document.getElementById('message');
        const startBtn = document.getElementById('startBtn');
        const clickWheel = document.getElementById('clickWheel');
        const centerButton = document.getElementById('centerButton');

        // iPod monochrome colors
        const BG_COLOR = '#9cb896';
        const FG_COLOR = '#000000';

        // Click wheel control variables
        let lastAngle = null;
        let wheelActive = false;

        // Game variables
        let score = 0;
        let lives = 3;
        let level = 1;
        let gameRunning = false;
        let animationId;
        let lastTouchX = null;

        // Paddle
        const paddle = {
            width: 50,
            height: 6,
            x: canvas.width / 2 - 25,
            y: canvas.height - 20,
            speed: 8
        };

        // Ball
        const ball = {
            x: canvas.width / 2,
            y: canvas.height - 30,
            radius: 3,
            dx: 3,
            dy: -3,
            launched: false
        };

        // Bricks
        const brickRowCount = 6;
        const brickColumnCount = 10;
        const brickWidth = 28;
        const brickHeight = 8;
        const brickPadding = 4;
        const brickOffsetTop = 20;
        const brickOffsetLeft = 4;

        let bricks = [];

        // Initialize bricks
        function createBricks() {
            bricks = [];
            for (let c = 0; c < brickColumnCount; c++) {
                bricks[c] = [];
                for (let r = 0; r < brickRowCount; r++) {
                    bricks[c][r] = { x: 0, y: 0, status: 1 };
                }
            }
        }

        // Draw bricks in monochrome iPod style
        function drawBricks() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    if (bricks[c][r].status === 1) {
                        const brickX = c * (brickWidth + brickPadding) + brickOffsetLeft;
                        const brickY = r * (brickHeight + brickPadding) + brickOffsetTop;
                        bricks[c][r].x = brickX;
                        bricks[c][r].y = brickY;
                        
                        // Solid black brick
                        ctx.fillStyle = FG_COLOR;
                        ctx.fillRect(brickX, brickY, brickWidth, brickHeight);
                        
                        // Inner border for depth
                        ctx.strokeStyle = BG_COLOR;
                        ctx.lineWidth = 1;
                        ctx.strokeRect(brickX + 1, brickY + 1, brickWidth - 2, brickHeight - 2);
                    }
                }
            }
        }

        // Draw paddle
        function drawPaddle() {
            ctx.fillStyle = FG_COLOR;
            ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
        }

        // Draw ball
        function drawBall() {
            ctx.fillStyle = FG_COLOR;
            ctx.beginPath();
            ctx.arc(Math.floor(ball.x), Math.floor(ball.y), ball.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();
        }

        // Move ball
        function moveBall() {
            if (!ball.launched) {
                ball.x = paddle.x + paddle.width / 2;
                ball.y = paddle.y - ball.radius - 2;
                return;
            }

            ball.x += ball.dx;
            ball.y += ball.dy;

            // Wall collision (left and right)
            if (ball.x + ball.radius > canvas.width || ball.x - ball.radius < 0) {
                ball.dx *= -1;
            }

            // Wall collision (top)
            if (ball.y - ball.radius < 0) {
                ball.dy *= -1;
            }

            // Paddle collision
            if (ball.y + ball.radius >= paddle.y &&
                ball.y - ball.radius <= paddle.y + paddle.height &&
                ball.x >= paddle.x &&
                ball.x <= paddle.x + paddle.width) {
                
                // Calculate hit position for angle
                let hitPos = (ball.x - paddle.x) / paddle.width;
                ball.dx = (hitPos - 0.5) * 6;
                ball.dy = -Math.abs(ball.dy);
            }

            // Bottom wall - lose a life
            if (ball.y - ball.radius > canvas.height) {
                lives--;
                livesEl.textContent = lives;
                
                if (lives === 0) {
                    gameOver();
                } else {
                    resetBall();
                }
            }
        }

        // Collision detection
        function collisionDetection() {
            for (let c = 0; c < brickColumnCount; c++) {
                for (let r = 0; r < brickRowCount; r++) {
                    const b = bricks[c][r];
                    if (b.status === 1) {
                        if (ball.x + ball.radius > b.x &&
                            ball.x - ball.radius < b.x + brickWidth &&
                            ball.y + ball.radius > b.y &&
                            ball.y - ball.radius < b.y + brickHeight) {
                            
                            ball.dy *= -1;
                            b.status = 0;
                            score += 10;
                            scoreEl.textContent = score;

                            // Check win
                            let allDestroyed = true;
                            for (let cc = 0; cc < brickColumnCount; cc++) {
                                for (let rr = 0; rr < brickRowCount; rr++) {
                                    if (bricks[cc][rr].status === 1) {
                                        allDestroyed = false;
                                        break;
                                    }
                                }
                                if (!allDestroyed) break;
                            }
                            
                            if (allDestroyed) {
                                nextLevel();
                            }
                        }
                    }
                }
            }
        }

        // Reset ball
        function resetBall() {
            ball.x = canvas.width / 2;
            ball.y = canvas.height - 30;
            ball.dx = 3;
            ball.dy = -3;
            ball.launched = false;
            paddle.x = canvas.width / 2 - paddle.width / 2;
        }

        // Next level
        function nextLevel() {
            level++;
            ball.dx *= 1.1;
            ball.dy *= 1.1;
            createBricks();
            resetBall();
            messageEl.textContent = `LEVEL ${level}`;
            setTimeout(() => messageEl.textContent = '', 1500);
        }

        // Game over
        function gameOver() {
            gameRunning = false;
            cancelAnimationFrame(animationId);
            messageEl.textContent = `GAME OVER - ${score}`;
            startBtn.textContent = '▶ RETRY';
            startBtn.style.display = 'inline-block';
        }

        // Draw everything
        function draw() {
            // Clear with background color
            ctx.fillStyle = BG_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drawBricks();
            drawPaddle();
            drawBall();
            collisionDetection();
            moveBall();

            if (gameRunning) {
                animationId = requestAnimationFrame(draw);
            }
        }

        // Touch controls for mobile
        function handleTouch(e) {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const touch = e.touches[0];
            const touchX = (touch.clientX - rect.left) * scaleX;
            
            paddle.x = touchX - paddle.width / 2;
            
            // Keep paddle in bounds
            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > canvas.width) {
                paddle.x = canvas.width - paddle.width;
            }
        }

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleTouch(e);
            if (gameRunning && !ball.launched) {
                ball.launched = true;
                messageEl.textContent = '';
            }
        });

        canvas.addEventListener('touchmove', handleTouch);

        // Mouse controls for desktop
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const mouseX = (e.clientX - rect.left) * scaleX;
            paddle.x = mouseX - paddle.width / 2;

            if (paddle.x < 0) paddle.x = 0;
            if (paddle.x + paddle.width > canvas.width) {
                paddle.x = canvas.width - paddle.width;
            }
        });

        canvas.addEventListener('click', () => {
            if (gameRunning && !ball.launched) {
                ball.launched = true;
                messageEl.textContent = '';
            }
        });

        // Click wheel controls
        function getAngle(e, element) {
            const rect = element.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            
            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            const dx = clientX - centerX;
            const dy = clientY - centerY;
            return Math.atan2(dy, dx);
        }

        function handleWheelMove(e) {
            if (!wheelActive) return;
            e.preventDefault();
            
            const currentAngle = getAngle(e, clickWheel);
            
            if (lastAngle !== null) {
                let delta = currentAngle - lastAngle;
                
                // Handle angle wrap-around
                if (delta > Math.PI) delta -= 2 * Math.PI;
                if (delta < -Math.PI) delta += 2 * Math.PI;
                
                // Move paddle based on rotation
                const sensitivity = 80;
                paddle.x += delta * sensitivity;
                
                // Keep paddle in bounds
                if (paddle.x < 0) paddle.x = 0;
                if (paddle.x + paddle.width > canvas.width) {
                    paddle.x = canvas.width - paddle.width;
                }
            }
            
            lastAngle = currentAngle;
        }

        // Mouse events for click wheel
        clickWheel.addEventListener('mousedown', (e) => {
            if (e.target === centerButton) return;
            wheelActive = true;
            lastAngle = getAngle(e, clickWheel);
        });

        document.addEventListener('mousemove', handleWheelMove);

        document.addEventListener('mouseup', () => {
            wheelActive = false;
            lastAngle = null;
        });

        // Touch events for click wheel
        clickWheel.addEventListener('touchstart', (e) => {
            const touch = e.touches[0];
            const rect = clickWheel.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dx = touch.clientX - centerX;
            const dy = touch.clientY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            // Check if touch is on the outer ring (not center button)
            if (distance > 40) {
                wheelActive = true;
                lastAngle = getAngle(e, clickWheel);
            }
        });

        document.addEventListener('touchmove', handleWheelMove);

        document.addEventListener('touchend', () => {
            wheelActive = false;
            lastAngle = null;
        });

        // Center button launches ball
        centerButton.addEventListener('click', (e) => {
            e.stopPropagation();
            if (gameRunning && !ball.launched) {
                ball.launched = true;
                messageEl.textContent = '';
            }
        });

        centerButton.addEventListener('touchstart', (e) => {
            e.preventDefault();
            e.stopPropagation();
            if (gameRunning && !ball.launched) {
                ball.launched = true;
                messageEl.textContent = '';
            }
        });

        // Start game
        function startGame() {
            score = 0;
            lives = 3;
            level = 1;
            scoreEl.textContent = score;
            livesEl.textContent = lives;
            messageEl.textContent = 'ROTATE WHEEL';
            
            createBricks();
            resetBall();
            
            gameRunning = true;
            startBtn.style.display = 'none';
            draw();
        }

        startBtn.addEventListener('click', startGame);
        startBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startGame();
        });

        // Initial draw
        createBricks();
        ctx.fillStyle = BG_COLOR;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawBricks();
        drawPaddle();
        drawBall();
    </script>
</body>
</html>
