<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Snake — Nokia 3310</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=VT323&family=Share+Tech+Mono&display=swap');

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --nokia-body:  #3a3a4a;
    --nokia-light: #4e4e60;
    --nokia-dark:  #2a2a38;
    --screen-bg:   #8bac0f;
    --screen-dark: #0f380f;
    --screen-light:#9bbc0f;
    --screen-mid:  #306230;

    /* ── Layout math ──────────────────────────────────────────
       phone-width  = 380px
       phone-pad    = 22px each side  → inner = 336px
       bezel-pad    = 12px each side  → screen-inner = 312px
       screen-inner-pad = 6px each side → canvas = 300px wide
       ──────────────────────────────────────────────────────── */
    --phone-w: 380px;
    --phone-px: 22px;
    --bezel-px: 12px;
    --screen-px: 6px;
    --canvas-w: 300px;   /* phone-w - 2*(phone-px+bezel-px+screen-px) = 380-2*40 = 300 */
    --canvas-h: 260px;
  }

  body {
    background: #1a1a2e;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    font-family: 'VT323', monospace;
    overflow: hidden;
    background-image:
      radial-gradient(ellipse at 20% 50%, rgba(26,26,80,0.8) 0%, transparent 60%),
      radial-gradient(ellipse at 80% 20%, rgba(10,10,50,0.6) 0%, transparent 50%);
  }

  /* ── Phone shell ── */
  .phone {
    width: var(--phone-w);
    background: linear-gradient(160deg, var(--nokia-light) 0%, var(--nokia-body) 40%, var(--nokia-dark) 100%);
    border-radius: 36px 36px 50px 50px;
    padding: 24px var(--phone-px) 32px;
    box-shadow:
      0 0 0 2px #222230,
      0 24px 70px rgba(0,0,0,0.85),
      inset 0 1px 0 rgba(255,255,255,0.15),
      inset 0 -2px 4px rgba(0,0,0,0.5);
    position: relative;
    user-select: none;
  }

  .phone::before {
    content: '';
    position: absolute;
    top: 12px; left: 14px; right: 14px;
    height: 38%;
    background: linear-gradient(180deg, rgba(255,255,255,0.06) 0%, transparent 100%);
    border-radius: 24px 24px 0 0;
    pointer-events: none;
  }

  /* ── Nokia brand ── */
  .brand {
    text-align: center;
    color: rgba(255,255,255,0.25);
    font-family: 'Share Tech Mono', monospace;
    font-size: 12px;
    letter-spacing: 7px;
    text-transform: uppercase;
    margin-bottom: 14px;
    padding-top: 4px;
  }

  /* ── Screen bezel (dark surround) ── */
  .screen-bezel {
    background: #080810;
    border-radius: 10px;
    padding: var(--bezel-px);
    box-shadow:
      inset 0 3px 10px rgba(0,0,0,0.95),
      inset 0 0 0 1px rgba(0,0,0,0.6),
      0 1px 0 rgba(255,255,255,0.05);
    margin-bottom: 22px;
  }

  /* ── Green screen area ── */
  .screen-inner {
    background: var(--screen-bg);
    border-radius: 5px;
    padding: var(--screen-px);
    position: relative;
    box-shadow:
      inset 0 0 24px rgba(0,0,0,0.2),
      0 0 12px rgba(139,172,15,0.35);
    /* Prevent any overflow */
    overflow: hidden;
  }

  /* scanlines */
  .screen-inner::after {
    content: '';
    position: absolute;
    inset: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent 0px, transparent 2px,
      rgba(0,0,0,0.04) 2px, rgba(0,0,0,0.04) 4px
    );
    pointer-events: none;
    border-radius: 5px;
    z-index: 5;
  }

  /* ── HUD row ── */
  .hud {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 5px;
    padding: 0 3px;
  }

  .hud-text {
    font-family: 'VT323', monospace;
    font-size: 17px;
    color: var(--screen-dark);
    line-height: 1;
  }

  .speed-dots { display: flex; gap: 4px; align-items: center; }
  .dot {
    width: 6px; height: 6px;
    border-radius: 50%;
    background: var(--screen-dark);
    opacity: 0.25;
  }
  .dot.active { opacity: 1; }

  /* ── Canvas ── */
  canvas {
    display: block;
    width: var(--canvas-w);
    height: var(--canvas-h);
    image-rendering: pixelated;
  }

  /* ── Overlay ── */
  .overlay {
    position: absolute;
    /* sit inside screen-inner's padding box, above the canvas */
    top: var(--screen-px); left: var(--screen-px);
    right: var(--screen-px); bottom: var(--screen-px);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: var(--screen-bg);
    border-radius: 3px;
    z-index: 10;
    gap: 8px;
  }

  .overlay.hidden { display: none; }

  .overlay-title {
    font-family: 'VT323', monospace;
    font-size: 42px;
    color: var(--screen-dark);
    line-height: 1;
    letter-spacing: 3px;
  }

  .overlay-sub {
    font-family: 'VT323', monospace;
    font-size: 17px;
    color: var(--screen-mid);
    text-align: center;
    line-height: 1.3;
  }

  .blink { animation: blink 1s step-end infinite; }
  @keyframes blink { 0%,100%{opacity:1} 50%{opacity:0} }

  /* ── Buttons ── */
  .controls-top {
    display: flex;
    justify-content: center;
    gap: 18px;
  }

  .btn-small {
    background: linear-gradient(160deg, #555568, #2a2a38);
    color: rgba(255,255,255,0.75);
    border: none;
    border-radius: 10px;
    padding: 10px 32px;
    font-family: 'VT323', monospace;
    font-size: 17px;
    cursor: pointer;
    box-shadow: 0 4px 0 #111120, inset 0 1px 0 rgba(255,255,255,0.12);
    transition: transform 0.08s, box-shadow 0.08s;
    letter-spacing: 1px;
    text-transform: uppercase;
  }

  .btn-small:active {
    transform: translateY(3px);
    box-shadow: 0 1px 0 #111120;
  }

  .hint {
    text-align: center;
    color: rgba(255,255,255,0.14);
    font-family: 'Share Tech Mono', monospace;
    font-size: 10px;
    letter-spacing: 1.5px;
    margin-top: 12px;
    text-transform: uppercase;
  }
</style>
</head>
<body>

<div class="phone">
  <div class="brand">Nokia</div>

  <div class="screen-bezel">
    <div class="screen-inner">
      <!-- HUD -->
      <div class="hud">
        <span class="hud-text">SCR: <span id="score">0</span></span>
        <div class="speed-dots">
          <div class="dot active" id="d1"></div>
          <div class="dot" id="d2"></div>
          <div class="dot" id="d3"></div>
          <div class="dot" id="d4"></div>
          <div class="dot" id="d5"></div>
        </div>
        <span class="hud-text">HI: <span id="hiscore">0</span></span>
      </div>

      <!-- Canvas wrapper keeps overlay aligned to canvas -->
      <div style="position:relative; line-height:0;">
        <canvas id="gameCanvas"></canvas>
        <div class="overlay" id="overlay">
          <div class="overlay-title">SNAKE</div>
          <div class="overlay-sub" style="color:var(--screen-dark); font-size:14px; letter-spacing:2px;">▓▓▓▓▓▓▓▓▓▓▓▓▓▓</div>
          <div class="overlay-sub blink" id="overlayMsg">PRESS ENTER TO PLAY</div>
          <div class="overlay-sub" id="overlayScore" style="display:none;"></div>
        </div>
      </div>
    </div>
  </div>

  <div class="controls-top">
    <button class="btn-small" id="btnPause">PAUSE</button>
    <button class="btn-small" id="btnSpeed">SPEED</button>
  </div>

  <div class="hint">Arrow Keys / WASD &nbsp;·&nbsp; Enter to Start</div>
</div>

<script>
(function () {
  const canvas = document.getElementById('gameCanvas');
  const ctx    = canvas.getContext('2d');

  // --- Grid config ---
  const COLS = 25, ROWS = 20;

  // Match canvas pixel size to CSS display size exactly
  // CSS vars: --canvas-w = 300, --canvas-h = 260
  const CSSw = 300, CSSh = 260;
  canvas.width  = CSSw;
  canvas.height = CSSh;
  // canvas CSS size is set in stylesheet via width/height vars

  const CW = CSSw / COLS;  // 12
  const CH = CSSh / ROWS;  // 13

  const C_BG    = '#8bac0f';
  const C_DARK  = '#0f380f';
  const C_MID   = '#306230';
  const C_LIGHT = '#9bbc0f';

  // speeds[i] = ms per grid step at speed level i+1
  const STEP_MS = [300, 220, 160, 110, 70];

  let snake;       // array of {x,y} grid cells, index 0 = head
  let prevSnake;   // snake positions at start of current step (for interpolation)
  let dir, nextDir;
  let food;
  let score, foodEaten;
  let hiScore  = 0;
  let running  = false;
  let paused   = false;
  let gameOver = false;
  let speed    = 1;  // 1–5

  // rAF state
  let rafId      = null;
  let lastStepTs = 0;   // timestamp of last logical step
  let interpT    = 0;   // 0..1 fraction through current step

  // --- Helpers ---
  function stepMs() { return STEP_MS[speed - 1]; }

  function updateScore() {
    document.getElementById('score').textContent = score;
    if (score > hiScore) {
      hiScore = score;
      document.getElementById('hiscore').textContent = hiScore;
    }
  }

  function updateSpeedDots() {
    for (let i = 1; i <= 5; i++)
      document.getElementById('d' + i).classList.toggle('active', i <= speed);
  }

  function placeFood() {
    let pos;
    do {
      pos = { x: Math.floor(Math.random() * COLS), y: Math.floor(Math.random() * ROWS) };
    } while (snake.some(s => s.x === pos.x && s.y === pos.y));
    food = pos;
  }

  function cloneSnake(s) { return s.map(c => ({ ...c })); }

  // --- Init ---
  function init() {
    const mx = Math.floor(COLS / 2), my = Math.floor(ROWS / 2);
    snake     = [{ x: mx, y: my }, { x: mx - 1, y: my }, { x: mx - 2, y: my }];
    prevSnake = cloneSnake(snake);
    dir       = { x: 1, y: 0 };
    nextDir   = { x: 1, y: 0 };
    score     = 0;
    foodEaten = 0;
    updateScore();
    placeFood();
    gameOver  = false;
    paused    = false;
    interpT   = 0;
  }

  // --- Logical step (advances grid positions) ---
  function step() {
    dir = { ...nextDir };
    const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

    if (head.x < 0 || head.x >= COLS || head.y < 0 || head.y >= ROWS) { endGame(); return; }
    if (snake.some(s => s.x === head.x && s.y === head.y))             { endGame(); return; }

    prevSnake = cloneSnake(snake);
    snake.unshift(head);

    if (head.x === food.x && head.y === food.y) {
      score += speed * 10;
      foodEaten++;
      updateScore();
      placeFood();
      if (foodEaten % 5 === 0 && speed < 5) {
        speed++;
        updateSpeedDots();
      }
      // prevSnake needs a tail placeholder so interpolation doesn't pop visually
      prevSnake.push(prevSnake[prevSnake.length - 1]);
    } else {
      snake.pop();
    }
  }

  // --- rAF loop ---
  function loop(ts) {
    if (!running) return;
    rafId = requestAnimationFrame(loop);

    if (paused) return;

    const elapsed = ts - lastStepTs;
    const ms      = stepMs();
    interpT       = Math.min(elapsed / ms, 1);

    if (elapsed >= ms) {
      step();
      if (!running) return;   // endGame() may have stopped loop
      lastStepTs = ts;
      interpT    = 0;
    }

    draw(interpT);
  }

  // --- Draw with interpolation ---
  function draw(t = 1) {
    // Background
    ctx.fillStyle = C_BG;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Grid dots
    ctx.fillStyle = C_LIGHT;
    for (let r = 0; r < ROWS; r++)
      for (let c = 0; c < COLS; c++)
        ctx.fillRect(c * CW + CW / 2 - 0.5, r * CH + CH / 2 - 0.5, 1, 1);

    // Food
    const fx = food.x * CW, fy = food.y * CH;
    ctx.fillStyle = C_DARK;
    ctx.fillRect(fx + 2, fy + 1, CW - 4, CH - 2);
    ctx.fillRect(fx + 1, fy + 2, CW - 2, CH - 4);

    // Snake — interpolate each segment between prevSnake and snake
    for (let i = 0; i < snake.length; i++) {
      const cur  = snake[i];
      const prev = prevSnake[i] || cur;

      // pixel position (interpolated)
      const px = (prev.x + (cur.x - prev.x) * t) * CW;
      const py = (prev.y + (cur.y - prev.y) * t) * CH;

      if (i === 0) {
        // Head
        ctx.fillStyle = C_DARK;
        ctx.fillRect(px + 1, py + 1, CW - 2, CH - 2);
        // Eyes
        ctx.fillStyle = C_BG;
        if      (dir.x ===  1) { ctx.fillRect(px+CW-4,py+2,2,2); ctx.fillRect(px+CW-4,py+CH-4,2,2); }
        else if (dir.x === -1) { ctx.fillRect(px+2,py+2,2,2);    ctx.fillRect(px+2,py+CH-4,2,2); }
        else if (dir.y === -1) { ctx.fillRect(px+2,py+2,2,2);    ctx.fillRect(px+CW-4,py+2,2,2); }
        else                   { ctx.fillRect(px+2,py+CH-4,2,2); ctx.fillRect(px+CW-4,py+CH-4,2,2); }
      } else {
        ctx.fillStyle = i % 2 === 0 ? C_DARK : C_MID;
        ctx.fillRect(px + 1, py + 1, CW - 2, CH - 2);
      }
    }
  }

  // --- End game ---
  function endGame() {
    running  = false;
    gameOver = true;
    cancelAnimationFrame(rafId);
    let f = 0;
    const fi = setInterval(() => {
      ctx.fillStyle = f % 2 === 0 ? C_DARK : C_BG;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      if (++f >= 6) {
        clearInterval(fi);
        draw(1);
        showOverlay('GAME OVER', 'SCORE: ' + score, 'PRESS ENTER');
      }
    }, 100);
  }

  // --- Overlays ---
  function showOverlay(title, sub, msg) {
    const ov = document.getElementById('overlay');
    ov.classList.remove('hidden');
    ov.querySelector('.overlay-title').textContent = title;
    document.getElementById('overlayMsg').textContent = msg;
    const sc = document.getElementById('overlayScore');
    if (sub) { sc.style.display = 'block'; sc.textContent = sub; }
    else      { sc.style.display = 'none'; }
  }

  function hideOverlay() {
    document.getElementById('overlay').classList.add('hidden');
  }

  // --- Start / Restart ---
  function startGame() {
    cancelAnimationFrame(rafId);
    init();
    hideOverlay();
    running    = true;
    speed      = 1;
    updateSpeedDots();
    lastStepTs = performance.now();
    rafId      = requestAnimationFrame(loop);
  }

  // --- Direction ---
  function setDir(dx, dy) {
    if (!running || paused) return;
    if (dx ===  1 && dir.x === -1) return;
    if (dx === -1 && dir.x ===  1) return;
    if (dy ===  1 && dir.y === -1) return;
    if (dy === -1 && dir.y ===  1) return;
    nextDir = { x: dx, y: dy };
  }

  // --- Keyboard ---
  document.addEventListener('keydown', e => {
    switch (e.key) {
      case 'ArrowUp':    case 'w': e.preventDefault(); setDir(0, -1); break;
      case 'ArrowDown':  case 's': e.preventDefault(); setDir(0,  1); break;
      case 'ArrowLeft':  case 'a': e.preventDefault(); setDir(-1, 0); break;
      case 'ArrowRight': case 'd': e.preventDefault(); setDir( 1, 0); break;
      case 'Enter': case ' ':
        if (!running || gameOver) startGame();
        else togglePause();
        break;
    }
  });

  function togglePause() {
    if (!running || gameOver) return;
    paused = !paused;
    if (paused) showOverlay('PAUSED', null, 'PRESS ENTER');
    else        hideOverlay();
  }

  // --- Buttons ---
  document.getElementById('btnPause').addEventListener('click', togglePause);
  document.getElementById('btnSpeed').addEventListener('click', () => {
    if (!running) return;
    speed = speed < 5 ? speed + 1 : 1;
    updateSpeedDots();
    // Don't reset lastStepTs — the new speed takes effect naturally next step
  });

  // --- Initial blank screen ---
  ctx.fillStyle = C_BG;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  updateSpeedDots();
})();
</script>
</body>
</html>
